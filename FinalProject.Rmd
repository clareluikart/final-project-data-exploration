---
title: "GEOG0114Final"
author: "Clare Rickard"
date: "2024-12-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Adding Libraries
```{r libraries}
#libraries used
library(here)
library(sf)
library(tmap)
library(sp)
library(janitor)
library(dplyr)
library(ggplot2)
library(terra)
library(tidycensus)
library(raster)
library(spdep)
```
## Calculating NDVI
### Creating total NDVI area
```{r setup_NDVI_25, eval = FALSE}
# Step 1: Define input and output folders
input_folder <- "laip/" # Replace with your folder path
output_folder <- "laip/ndvi_output/" # Folder to save NDVI rasters

# Create output folder if it doesn't exist
if (!dir.exists(output_folder)) dir.create(output_folder)

# Step 2: Load all TIFs
tif_files <- list.files(input_folder, pattern = "\\.tif$", full.names = TRUE)

# Step 3: Process each TIF to calculate NDVI and save
for (tif_file in tif_files) {
  cat("Processing:", tif_file, "\n")
  
  # Load the TIF
  tif <- stack(tif_file)
  
  # Extract red and NIR bands (adjust band numbers if needed)
  red_band <- tif[[1]]
  nir_band <- tif[[4]]
  
  # Calculate NDVI
  ndvi <- (nir_band - red_band) / (nir_band + red_band)
  
  # Define output file name
  output_file <- gsub(".tif$", "_NDVI.tif", basename(tif_file))
  output_path <- file.path(output_folder, output_file)
  
  # Save the NDVI raster
  writeRaster(ndvi, output_path, format = "GTiff", overwrite = TRUE)
  
  cat("Saved NDVI raster to:", output_path, "\n")
}
```
### Classifying NDVI
``` {r NDVI_classify, eval=FALSE}
input_folder <- "laip/" # Replace with your folder path
output_folder <- "laip/ndvi_output/" # Folder to save NDVI rasters

# Step 4: List all NDVI rasters
ndvi_files <- list.files(output_folder, pattern = "_NDVI\\.tif$", full.names = TRUE)

# Step 7: Resample all NDVI rasters to the unified extent and resolution
cat("Resampling rasters...\n")
terra_rasters <- lapply(ndvi_files, function(ndvi_file) {
  r <- terra::rast(ndvi_file)
  return(r)
})

# Step 8: Mosaic resampled NDVI rasters together
cat("Mosaicking rasters...\n")
mosaicked_raster_NDVI <- do.call(merge, c(terra_rasters))
reclass_matrix <- matrix(c(
  -Inf, .2, 0,   # Less or equal to .2 -> class 0
  .2, Inf, 1   # More than .2 -> class 1
), ncol = 3, byrow = TRUE)
mosaicked_raster_NDVI <- classify(mosaicked_raster_NDVI, reclass_matrix, right=TRUE)

plot(mosaicked_raster_NDVI)

writeRaster(mosaicked_raster_NDVI, "mosaicked_raster_060_NDVI.tif", overwrite = TRUE)
cat("Mosaicked NDVI raster saved to:", mosaic_output_file_NDVI, "\n")
```
### Plotting NDVI at .6 meter resolution (NAD83 / UTM zone 10N (EPSG:26910))
```{r NDVI_25}
ndvi_25 <- rast("mosaicked_raster_060_NDVI.tif")
plot(ndvi_25)
```
## Calculating nDSM
### Setting up DEM
```{r setup25DEM, eval=FALSE}
# Define the folder containing the files
input_folder <- "nDSM_stuff/ca2023_sanfran_dem_Job1102345/"

# List all .tif files in the folder that end with "_XXX.tif"
dem_tifs <- list.files(path = input_folder, pattern = "_\\d{3}\\.tif$", full.names = TRUE)

# Check if the list is not empty
if (length(dem_tifs) == 0) {
  stop("No matching .tif files found in the directory.")
}

# Load and mosaic the rasters
rasters <- lapply(dem_tifs, terra::rast) # Ensure 'terra::rast' is used to load rasters
new_raster <- do.call(terra::mosaic, c(rasters, fun = "mean"))

# Save the result
output_file <- "mosaicked_dem_25.tif"
terra::writeRaster(new_raster, output_file, overwrite = TRUE)

cat("Mosaic saved to", output_file, "\n")
```
### Plotting DEM at .82-foot (.25 meter) resolution (NAD83(2011) / California zone 3 (ftUS) (EPSG:6420))
```{r import25DEM}
dem_raster <- rast("mosaicked_dem_25.tif")
plot(dem_raster, main = "Digital Elevation Model (.25m Resolution)")
```
### Setting up DSM
```{r setup_25DSM, eval = FALSE}
# List all chunk files
chunk_files <- list.files(path = "python_test/output_tifs/", pattern = "chunk_.*\\.tif$", full.names = TRUE)

# Load and mosaic the rasters
rasters <- lapply(chunk_files, rast)
new_raster <- do.call(terra::mosaic, c(rasters, fun = "mean"))

# Save the final mosaic
writeRaster(new_raster, "san_francisco_25_dsm.tif", overwrite = TRUE)
```
### Plotting DSM at (.25 meter) resolution (WGS 84 / Pseudo-Mercator (EPSG:3857) )
```{r import_25DSM}
dsm_raster <- rast("san_francisco_25_dsm.tif")
plot(dsm_raster, main = "Digital Surface Model (.25m Resolution)")
```
### Changing DEM vertical units from feet to metres
```{r metresDEM, eval=FALSE}
writeRaster((raster(here("mosaicked_dem_25.tif"))*0.3048), "dem_metres.tif", overwrite = TRUE)
```

### Subtracting DEM from DSM to get nDSM (WGS 84 / Pseudo-Mercator (EPSG:3857))
```{r setup25NDSM, eval=FALSE}
terra_dem <- terra::rast("dem_metres.tif")

terra_dsm <- terra::rast("san_francisco_25_dsm.tif")

terra_dem <- terra::project(terra_dem, terra_dsm, method="bilinear", res=.25)

terra_dsm <- terra::crop(terra_dsm, terra_dem, ext=TRUE)
terra_dem <- terra::crop(terra_dem, terra_dsm, ext=TRUE)

noaa_ndsm <- terra_dsm - terra_dem
writeRaster(noaa_ndsm, "san_francisco_ndsm_25.tif", overwrite = TRUE)
```
### Plotting nDSM at (.25 meter) resolution (WGS 84 / Pseudo-Mercator (EPSG:3857))
```{r import_NDSM_25}
noaa_ndsm <- rast("san_francisco_ndsm_25.tif")
plot(noaa_ndsm)
```
### Reclassifying nDSM to find areas above 8 feet
```{r classify_nDSM_25}
feet_to_meters <- function(feet) feet * 0.3048
threshold_1 <- feet_to_meters(1)   # 1 foot to meters
threshold_8 <- feet_to_meters(8)   # 8 feet to meters

# Reclassify raster
reclass_matrix <- matrix(c(
  -Inf, threshold_1, 1,   # Less than 1 foot -> class 1
  threshold_1, threshold_8, 2,   # 1-8 feet -> class 2
  threshold_8, Inf, 3     # Greater than 8 feet -> class 3
), ncol = 3, byrow = TRUE)

reclassified_raster_25 <- classify(noaa_ndsm, reclass_matrix)

# Define colors for the classes: yellow (class 1), blue (class 2), green (class 3)
colors <- c("yellow", "green", "blue")

writeRaster(reclassified_raster_25, "reclassified_25.tif", overwrite = TRUE)

# Plot the reclassified raster
plot(reclassified_raster_25, 
     col = colors, 
     legend = TRUE, 
     main = "Reclassified nDSM (Height Categories)",
     axes = FALSE, box = FALSE)
```

### Importing NDVI (NAD83 / UTM zone 10N (EPSG:26910)) and and Reclassified nDSM (WGS 84 / Pseudo-Mercator (EPSG:3857))
```{r import_NDVI_nDSM, eval=FALSE}
mosaicked_raster_NDVI <- rast("mosaicked_raster_060_NDVI.tif")
reclassified_raster_25 <- rast("reclassified_25.tif")
```
### Calculating tree cover 
```{r setup_treecover_raster_25, eval=FALSE}
mosaicked_raster_NDVI <- terra::project(mosaicked_raster_NDVI, reclassified_raster_25)

mosaicked_raster_NDVI <- terra::crop(mosaicked_raster_NDVI, reclassified_raster_25, mask=TRUE)

tree_cover <- (mosaicked_raster_NDVI == 1) & (reclassified_raster_25 == 3)
plot(tree_cover)

writeRaster(tree_cover, "treecover_25.tif", overwrite = TRUE)
```
### Plotting tree cover (WGS 84 / Pseudo-Mercator (EPSG:3857))
```{r import_tree_cover25}
tree_cover <- rast("treecover_25.tif")
plot(tree_cover, main = "Tree Cover, .25m resolution")
```
### Finding tree cover percent by area, using EPSG:3311 NAD83 / California Albers
```{r tree_cover_percent_setup, eval = FALSE}
# Define the bounds and resolution
xmin <- -221668.3543
ymin <- -31750.9275
xmax <- -206742.5916
ymax <- -17587.9157
resolution <- 0.25  # in meters

# Create a SpatRaster with the defined bounds and resolution
ncols <- round((xmax - xmin) / resolution)
nrows <- round((ymax - ymin) / resolution)

# Create the empty raster
r <- rast(nrows = nrows, ncols = ncols, ext = ext(xmin, xmax, ymin, ymax), resolution = resolution)

crs(r) <- "EPSG:3311"

# Load the raster data
raster_data <- terra::project(tree_cover, r)

writeRaster(raster_data, "treecover_25_3311.tif", overwrite = TRUE)

# Load the neighborhood shapefile
neighborhoods <- st_read("cb_2020_06_bg_500k.shp")%>%
  filter(., COUNTYFP == "075")%>%
  dplyr::select(., AFFGEOID,GEOID, geometry)

st_crs(neighborhoods) <- "EPSG:4326"

# Reproject neighborhoods to match the CRS of the raster
neighborhoods <- st_transform(neighborhoods, crs(raster_data))

results <- list()

# Loop through each polygon and calculate the tree cover percentage
for (i in 1:nrow(neighborhoods)) {
    # Extract the polygon
    neighborhood <- neighborhoods[i, ]
    
    # Extract tree cover values for the current polygon
    tree_cover_values <- extract(raster_data, neighborhood, fun = mean, na.rm = TRUE)
    
    # Calculate percentage of tree cover (assuming binary raster where TRUE = 1 and FALSE = 0)
    percentage_tree_cover <- tree_cover_values * 100  # Multiply by 100 to get percentage
    
    # Print the name of the neighborhood and the calculated percentage
    neighborhood_name <- neighborhood$GEOID  # Adjust to your actual column name for neighborhood names
    print(paste("Neighborhood:", neighborhood_name, "- Tree Cover Percentage:", round(percentage_tree_cover, 2), "%"))
    
    results[[i]] <- data.frame(neighborhood = neighborhood_name, tree_cover_percentage = percentage_tree_cover)
}

final_results <- do.call(rbind, results)

tree_cover_values <- final_results%>%
  dplyr::select(., "neighborhood", "tree_cover_percentage.m_3712212_se_10_060_20220519_NDVI")%>%
  dplyr::rename(., "GEOID" = "neighborhood")%>%
  dplyr::rename(., "tree_cover_percentage" = "tree_cover_percentage.m_3712212_se_10_060_20220519_NDVI")%>%
  dplyr::filter(!is.na(tree_cover_percentage))

# Add the extracted values to the neighborhoods dataframe
joined_values <- left_join(tree_cover_values, neighborhoods, by="GEOID")

joined_values <-  joined_values%>%
  dplyr::select(., GEOID, AFFGEOID, tree_cover_percentage)

write.csv(joined_values, "tree_cover_2.csv", row.names = FALSE)
```
### Plotting Urban Tree Canopy coverage by Census Block
```{r import_tree_cover_percent}
# Load and prepare the data
tree_cover_percent <- read.csv("tree_cover_2.csv") %>%
  dplyr::select(AFFGEOID, tree_cover_percentage)

neighborhoods <- st_read("cb_2020_06_bg_500k.shp") %>%
  filter(COUNTYFP == "075") %>%
  dplyr::select(AFFGEOID, GEOID, geometry)

# Ensure CRS is consistent
st_crs(neighborhoods) <- "EPSG:4326"

# Define extents for Alameda and Alcatraz
alameda_extent <- st_bbox(c(xmin = -122.337094, ymin = 37.775902, xmax = -122.318329, ymax = 37.799330), crs = st_crs(neighborhoods))
alcatraz_extent <- st_bbox(c(xmin = -122.427263, ymin = 37.824158, xmax = -122.418337, ymax = 37.830463), crs = st_crs(neighborhoods))

# Convert extents to sf polygons
alameda_polygon <- st_as_sfc(alameda_extent)
alcatraz_polygon <- st_as_sfc(alcatraz_extent)

# Combine polygons to create exclusion areas
exclude_areas <- st_union(alameda_polygon, alcatraz_polygon)

# Subtract exclusion areas from neighborhoods
neighborhoods <- st_difference(neighborhoods, exclude_areas)%>%
  left_join(., tree_cover_percent, by = "AFFGEOID") %>%
  filter(!is.na(tree_cover_percentage))

# Plot the final map
tmap_mode("plot")
tm_shape(neighborhoods) +
  tm_polygons("tree_cover_percentage", 
              palette = "Greens", 
              title = "Urban Tree Canopy Coverage, %",
              style = "cont", 
              lwd = 0) +  # Remove borders around polygons
  tm_layout(frame = FALSE, bg.color = "darkgray")
```
```{r calculate_total_coverage}

```

```{r spatial_autocorrelation_neighbors}
treasure_island_extent <- st_bbox(c(xmin = -122.380388, ymin = 37.805822, xmax = -122.358244, ymax = 37.835112), crs = st_crs(neighborhoods))
treasure_island <- st_as_sfc(treasure_island_extent)
neighborhoods_autocorrelation <- st_difference(neighborhoods, treasure_island)

coordsC <- neighborhoods_autocorrelation%>%
  st_centroid()%>%
  st_geometry()
SFC_nb <- neighborhoods_autocorrelation%>%
  poly2nb(., queen=T)
summary(SFC_nb)
#plot them
plot(SFC_nb, st_geometry(coordsC), col="red")
#add a map underneath
plot(neighborhoods_autocorrelation$geometry, add=T)
SFcensus.lw <- SFC_nb %>%
  nb2mat(., style="C")
#using row standardised here

print(sum(SFcensus.lw))
```
```{r global_morans}
SFcensus.lw <- SFC_nb %>%
  nb2listw(., style="C")
I_SFcensus_Global_UTC <- neighborhoods_autocorrelation %>%
  pull(tree_cover_percentage) %>%
  as.vector()%>%
  moran.test(., SFcensus.lw)

I_SFcensus_Global_UTC
```
```{r monte_carlo}
# run a Monte Carlo simulation 599 times
mc_model <- moran.mc(neighborhoods_autocorrelation$tree_cover_percentage, SFcensus.lw, nsim=599)

# inspect
mc_model
```

```{r local_morans}
I_SFC_Local_UTC <- neighborhoods_autocorrelation %>%
  pull(tree_cover_percentage) %>%
  as.vector()%>%
  localmoran(., SFcensus.lw, alternative = "greater")%>%
  as_tibble()

neighborhoods_autocorrelation <- neighborhoods_autocorrelation %>%
  mutate(UTC_I =as.numeric(I_SFC_Local_UTC$Ii))%>%
  mutate(UTC_Iz =as.numeric(I_SFC_Local_UTC$Z.Ii))%>%
  mutate(UTC_p =as.numeric(I_SFC_Local_UTC$'Pr(z > E(Ii))'))

breaks1<-c(-1000,-2.58,-1.96,-1.65,1.65,1.96,2.58,1000)
library(RColorBrewer)
MoranColours<- rev(brewer.pal(8, "RdGy"))
tm_shape(neighborhoods_autocorrelation) +
    tm_polygons("UTC_I",
        style="fixed",
        breaks=breaks1,
        palette=MoranColours,
        midpoint=NA,
        title="Local Moran's I, Urban Tree Canopy Coverage")+
  tm_layout(title = "San Francisco Census Blocks", 
            legend.outside = TRUE) +
  tm_scale_bar(position = c("right", "bottom")) +
  tm_compass(type = "arrow", position = c("left", "top"))
```
```{r local_morans_significance}
signif <- 0.1
# centers the variable of interest around its mean
neighborhoods_autocorrelation <- neighborhoods_autocorrelation %>%
  mutate(mean_UTC = tree_cover_percentage- mean(tree_cover_percentage))%>%
  mutate(mean_UTC = as.vector(mean_UTC))%>%
  mutate(mean_UTCI= UTC_I - mean(UTC_I))%>%
  mutate(quadrant = case_when(mean_UTC>0 & mean_UTCI >0 ~ 4,
         mean_UTC<0 & mean_UTCI <0 ~ 1,
         mean_UTC<0 & mean_UTCI >0 ~ 2,
         mean_UTC>0 & mean_UTCI <0 ~ 3))%>%
  mutate(quadrant=case_when(UTC_p > signif ~ 0, TRUE ~ quadrant))

brks <- c(0,1,2,3,4,5)
colors <- c("#f2f2f2", "#2c8399", "#8ddef2", "#F4A582", "#D6604D")

# had help from chatgpt in formatting this
tm_shape(neighborhoods_autocorrelation) +
    tm_polygons("quadrant",
        style="fixed",
        breaks=brks,
        labels = c("Insignificant P Value","Low UTCC with \nLow UTCC Neighbours","Low UTCC with \nHigh UTCC Neighbours","High UTCC with \nLow UTCC Neighbours","High UTCC with \nHigh UTCC Neighbours"),
        palette=colors,
        title="Centred UTCC and Moran's I",
        legend.show = FALSE)+
  tm_layout(legend.outside = TRUE, frame = FALSE, title= "Moran's I with Mean UTCC" 
            )+
  # Add text below the map
  tm_credits(
    "San Francisco",              # The text you want to display
    position = c("right", "top"),  # Centered at the bottom
    size = .75,                        # Adjust the size of the text
  )+
    tm_add_legend(
    type = "symbol",  # Use symbols for legend items (color boxes)
    labels = c(
      "Insignificant P Value",
      "Low UTC with \nLow UTC Neighbours",
      "Low UTC with \nHigh UTC Neighbours",
      "High UTC with \nLow UTC Neighbours",
      "High UTC with \nHigh UTC Neighbours"
    ),
    col = colors,  # Set the color values for the legend items
    shape = 15,    # Use filled squares (or other shapes if you prefer)
    size = 2,    # Adjust size of the symbols (boxes)
  ) +
  tm_scale_bar(position = c("right", "bottom")) +
  tm_compass(type = "arrow", position = c("left", "top"))
```

```{r adding_independent_variables}

```


```{r multivariable_linear_regression}

```

```{r spatial_lag_regression}

```

```{r spatial_error_regression}

```

```{r mgwr}

```