---
title: "GEOG0114Final"
author: "Clare Rickard"
date: "2024-12-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r libraries}
#libraries used
library(here)
library(sf)
library(tmap)
library(sp)
library(janitor)
library(dplyr)
library(ggplot2)
library(terra)
library(tidycensus)
library(raster)
```

```{r setup_NDVI, eval = FALSE}
# Step 1: Define input and output folders
input_folder <- "laip/" # Replace with your folder path
output_folder <- "laip/ndvi_output/" # Folder to save NDVI rasters

# Create output folder if it doesn't exist
if (!dir.exists(output_folder)) dir.create(output_folder)

# Step 2: Load all TIFs
tif_files <- list.files(input_folder, pattern = "\\.tif$", full.names = TRUE)

# Step 3: Process each TIF to calculate NDVI and save
for (tif_file in tif_files) {
  cat("Processing:", tif_file, "\n")
  
  # Load the TIF
  tif <- stack(tif_file)
  
  # Extract red and NIR bands (adjust band numbers if needed)
  red_band <- tif[[1]]
  nir_band <- tif[[4]]
  
  # Calculate NDVI
  ndvi <- (nir_band - red_band) / (nir_band + red_band)
  
  # Define output file name
  output_file <- gsub(".tif$", "_NDVI.tif", basename(tif_file))
  output_path <- file.path(output_folder, output_file)
  
  # Save the NDVI raster
  writeRaster(ndvi, output_path, format = "GTiff", overwrite = TRUE)
  
  cat("Saved NDVI raster to:", output_path, "\n")
}

# Step 4: List all NDVI rasters
ndvi_files <- list.files(output_folder, pattern = "_NDVI\\.tif$", full.names = TRUE)

# Step 5: Determine unified extent
cat("Calculating unified extent...\n")
xmin_all <- Inf
xmax_all <- -Inf
ymin_all <- Inf
ymax_all <- -Inf

for (ndvi_file in ndvi_files) {
  r <- raster(ndvi_file)
  raster_extent <- extent(r)
  
  xmin_all <- min(xmin_all, raster_extent[1])
  xmax_all <- max(xmax_all, raster_extent[2])
  ymin_all <- min(ymin_all, raster_extent[3])
  ymax_all <- max(ymax_all, raster_extent[4])
}

# Create a unified extent
unified_extent <- extent(xmin_all, xmax_all, ymin_all, ymax_all)
cat("Unified extent is:\n")
cat("xmin:", xmin_all, "xmax:", xmax_all, "ymin:", ymin_all, "ymax:", ymax_all, "\n")

# Step 6: Create a reference raster
reference_raster <- raster(unified_extent, crs = "+proj=utm +zone=10 +datum=NAD83 +units=m +no_defs")
res(reference_raster) <- 1 # Set resolution to 1 meter

# Step 7: Resample all NDVI rasters to the unified extent and resolution
cat("Resampling rasters...\n")
resampled_rasters <- lapply(ndvi_files, function(ndvi_file) {
  r <- raster(ndvi_file)
  r_resampled <- resample(r, reference_raster, method = "bilinear")
  return(r_resampled)
})

# Step 8: Mosaic resampled NDVI rasters together
cat("Mosaicking rasters...\n")
mosaicked_raster_NDVI <- do.call(mosaic, c(resampled_rasters, fun = "mean"))

# Step 9: Save the mosaicked NDVI raster
mosaic_output_file_NDVI <- file.path("laip/ndvi_output", "mosaicked_raster_NDVI.tif")
writeRaster(mosaicked_raster_NDVI, mosaic_output_file_NDVI, format = "GTiff", overwrite = TRUE)
cat("Mosaicked NDVI raster saved to:", mosaic_output_file_NDVI, "\n")
```


```{r NDVI}
ndvi <- raster("laip/ndvi_output/mosaicked_raster_NDVI.tif")
plot(ndvi)
```
```{r setup_NDVI_25, eval = FALSE}
# Step 1: Define input and output folders
input_folder <- "laip/" # Replace with your folder path
output_folder <- "laip/ndvi_output/" # Folder to save NDVI rasters

# Create output folder if it doesn't exist
if (!dir.exists(output_folder)) dir.create(output_folder)

# Step 2: Load all TIFs
tif_files <- list.files(input_folder, pattern = "\\.tif$", full.names = TRUE)

# Step 3: Process each TIF to calculate NDVI and save
for (tif_file in tif_files) {
  cat("Processing:", tif_file, "\n")
  
  # Load the TIF
  tif <- stack(tif_file)
  
  # Extract red and NIR bands (adjust band numbers if needed)
  red_band <- tif[[1]]
  nir_band <- tif[[4]]
  
  # Calculate NDVI
  ndvi <- (nir_band - red_band) / (nir_band + red_band)
  
  # Define output file name
  output_file <- gsub(".tif$", "_NDVI.tif", basename(tif_file))
  output_path <- file.path(output_folder, output_file)
  
  # Save the NDVI raster
  writeRaster(ndvi, output_path, format = "GTiff", overwrite = TRUE)
  
  cat("Saved NDVI raster to:", output_path, "\n")
}
```
``` {r NDVI_classify, eval=FALSE}
input_folder <- "laip/" # Replace with your folder path
output_folder <- "laip/ndvi_output/" # Folder to save NDVI rasters

# Step 4: List all NDVI rasters
ndvi_files <- list.files(output_folder, pattern = "_NDVI\\.tif$", full.names = TRUE)

# Step 7: Resample all NDVI rasters to the unified extent and resolution
cat("Resampling rasters...\n")
terra_rasters <- lapply(ndvi_files, function(ndvi_file) {
  r <- terra::rast(ndvi_file)
  return(r)
})

# Step 8: Mosaic resampled NDVI rasters together
cat("Mosaicking rasters...\n")
mosaicked_raster_NDVI <- do.call(merge, c(terra_rasters))
reclass_matrix <- matrix(c(
  -Inf, .2, 0,   # Less or equal to .2 -> class 0
  .2, Inf, 1   # More than .2 -> class 1
), ncol = 3, byrow = TRUE)
mosaicked_raster_NDVI <- classify(mosaicked_raster_NDVI, reclass_matrix, right=TRUE)

plot(mosaicked_raster_NDVI)

writeRaster(mosaicked_raster_NDVI, "mosaicked_raster_060_NDVI.tif", overwrite = TRUE)
cat("Mosaicked NDVI raster saved to:", mosaic_output_file_NDVI, "\n")
```


```{r NDVI_25}
ndvi_25 <- rast("mosaicked_raster_060_NDVI.tif")
plot(ndvi_25)
```

```{r setup25DEM, eval=FALSE}
# Define the folder containing the files
input_folder <- "nDSM_stuff/ca2023_sanfran_dem_Job1102345/"

# List all .tif files in the folder that end with "_XXX.tif"
dem_tifs <- list.files(path = input_folder, pattern = "_\\d{3}\\.tif$", full.names = TRUE)

# Check if the list is not empty
if (length(dem_tifs) == 0) {
  stop("No matching .tif files found in the directory.")
}

# Load and mosaic the rasters
rasters <- lapply(dem_tifs, terra::rast) # Ensure 'terra::rast' is used to load rasters
new_raster <- do.call(terra::mosaic, c(rasters, fun = "mean"))

# Save the result
output_file <- "mosaicked_dem_25.tif"
terra::writeRaster(new_raster, output_file, overwrite = TRUE)

cat("Mosaic saved to", output_file, "\n")
```
```{r import25DEM}
dem_raster <- raster(here("mosaicked_dem_25.tif"))
plot(dem_raster, main = "Digital Elevation Model (.25m Resolution)")
```

```{r setup_25DSM, eval = FALSE}
# List all chunk files
chunk_files <- list.files(path = "python_test/output_tifs/", pattern = "chunk_.*\\.tif$", full.names = TRUE)

# Load and mosaic the rasters
rasters <- lapply(chunk_files, rast)
new_raster <- do.call(terra::mosaic, c(rasters, fun = "mean"))

# Save the final mosaic
writeRaster(new_raster, "san_francisco_25_dsm.tif", overwrite = TRUE)
```
```{r import_25DSM}
dsm_raster <- rast("san_francisco_25_dsm.tif")
plot(dsm_raster, main = "Digital Surface Model (.25m Resolution)")
```

```{r metresDEM, eval=FALSE}
writeRaster((raster(here("mosaicked_dem_25.tif"))*0.3048), "dem_metres.tif", overwrite = TRUE)
```


```{r setup25NDSM, eval=FALSE}
terra_dem <- terra::rast("dem_metres.tif")

terra_dsm <- terra::rast("san_francisco_25_dsm.tif")

terra_dem <- terra::project(terra_dem, terra_dsm, method="bilinear", res=.25)

terra_dsm <- terra::crop(terra_dsm, terra_dem, ext=TRUE)
terra_dem <- terra::crop(terra_dem, terra_dsm, ext=TRUE)

noaa_ndsm <- terra_dsm - terra_dem
writeRaster(noaa_ndsm, "san_francisco_ndsm_25.tif", overwrite = TRUE)
```
```{r import_NDSM_25}
noaa_ndsm <- rast("san_francisco_ndsm_25.tif")
plot(noaa_ndsm)
```


```{r setup_treecover_25}
feet_to_meters <- function(feet) feet * 0.3048
threshold_1 <- feet_to_meters(1)   # 1 foot to meters
threshold_8 <- feet_to_meters(8)   # 8 feet to meters

# Reclassify raster
reclass_matrix <- matrix(c(
  -Inf, threshold_1, 1,   # Less than 1 foot -> class 1
  threshold_1, threshold_8, 2,   # 1-8 feet -> class 2
  threshold_8, Inf, 3     # Greater than 8 feet -> class 3
), ncol = 3, byrow = TRUE)

reclassified_raster_25 <- classify(noaa_ndsm, reclass_matrix)

# Define colors for the classes: yellow (class 1), blue (class 2), green (class 3)
colors <- c("yellow", "green", "blue")

writeRaster(reclassified_raster_25, "reclassified_25.tif", overwrite = TRUE)

# Plot the reclassified raster
plot(reclassified_raster_25, 
     col = colors, 
     legend = TRUE, 
     main = "Reclassified nDSM (Height Categories)",
     axes = FALSE, box = FALSE)
```

```{r import_NDVI_nDSM, eval=FALSE}
mosaicked_raster_NDVI <- rast("mosaicked_raster_060_NDVI.tif")
reclassified_raster_25 <- rast("reclassified_25.tif")
```

```{r setup_treecover_raster_25, eval=FALSE}
mosaicked_raster_NDVI <- terra::project(mosaicked_raster_NDVI, reclassified_raster_25)

mosaicked_raster_NDVI <- terra::crop(mosaicked_raster_NDVI, reclassified_raster_25, mask=TRUE)

tree_cover <- (mosaicked_raster_NDVI == 1) & (reclassified_raster_25 == 3)
plot(tree_cover)

writeRaster(tree_cover, "treecover_25.tif", overwrite = TRUE)
```
```{r import_tree_cover25}
tree_cover <- rast("treecover_25.tif")
plot(tree_cover, main = "Tree Cover, .25m resolution")
```

```{r}
# Load necessary libraries
library(sf)

# Define the coordinates in EPSG:4326 (WGS84)
coords <- data.frame(
  lon = c(-122.519531, -122.349243),
  lat = c(37.694959, 37.835819)
)

# Create an sf object from the WGS84 coordinates
sf_points <- st_as_sf(coords, 
                      coords = c("lon", "lat"), 
                      crs = 4326) # EPSG:4326 (WGS84)

# Transform the coordinates to EPSG:6319 (NAD83 / California Albers)
sf_points_6319 <- st_transform(sf_points, 6319)

# Extract the transformed coordinates
transformed_coords <- st_coordinates(sf_points_6319)

# Print the transformed coordinates
print(transformed_coords)
```

```{r tree_cover_percent_setup, eval = FALSE}
# Load the raster data
raster_data <- rast("treecover_25.tif")

# Load the neighborhood shapefile
neighborhoods <- st_read("cb_2020_06_bg_500k.shp")%>%
  filter(., COUNTYFP == "075")%>%
  select(., AFFGEOID,GEOID, geometry)

st_crs(neighborhoods) <- "EPSG:4326"

# Reproject neighborhoods to match the CRS of the raster
neighborhoods <- st_transform(neighborhoods, crs(raster_data))

results <- list()

# Loop through each polygon and calculate the tree cover percentage
for (i in 1:nrow(neighborhoods)) {
    # Extract the polygon
    neighborhood <- neighborhoods[i, ]
    
    # Extract tree cover values for the current polygon
    tree_cover_values <- extract(raster_data, neighborhood, fun = mean, na.rm = TRUE)
    
    # Calculate percentage of tree cover (assuming binary raster where TRUE = 1 and FALSE = 0)
    percentage_tree_cover <- tree_cover_values * 100  # Multiply by 100 to get percentage
    
    # Print the name of the neighborhood and the calculated percentage
    neighborhood_name <- neighborhood$GEOID  # Adjust to your actual column name for neighborhood names
    print(paste("Neighborhood:", neighborhood_name, "- Tree Cover Percentage:", round(percentage_tree_cover, 2), "%"))
    
    results[[i]] <- data.frame(neighborhood = neighborhood_name, tree_cover_percentage = percentage_tree_cover)
}

final_results <- do.call(rbind, results)

tree_cover_values <- final_results%>%
  select(., "neighborhood", "tree_cover_percentage.m_3712212_se_10_060_20220519_NDVI")%>%
  rename(., "GEOID" = "neighborhood")%>%
  rename(., "tree_cover_percentage" = "tree_cover_percentage.m_3712212_se_10_060_20220519_NDVI")%>%
  filter(!is.na(tree_cover_percentage))

# Add the extracted values to the neighborhoods dataframe
joined_values <- left_join(tree_cover_values, neighborhoods, by="GEOID")

joined_values <-  joined_values%>%
  select(., GEOID, AFFGEOID, tree_cover_percentage)

write.csv(joined_values, "tree_cover.csv", row.names = FALSE)
```
```{r import_tree_cover_percent}
# Load and prepare the data
tree_cover_percent <- read.csv("tree_cover.csv") %>%
  select(AFFGEOID, tree_cover_percentage)

neighborhoods <- st_read("cb_2020_06_bg_500k.shp") %>%
  filter(COUNTYFP == "075") %>%
  select(AFFGEOID, GEOID, geometry)

# Ensure CRS is consistent
st_crs(neighborhoods) <- "EPSG:4326"

# Define extents for Alameda and Alcatraz
alameda_extent <- st_bbox(c(xmin = -122.337094, ymin = 37.775902, xmax = -122.318329, ymax = 37.799330), crs = st_crs(neighborhoods))
alcatraz_extent <- st_bbox(c(xmin = -122.427263, ymin = 37.824158, xmax = -122.418337, ymax = 37.830463), crs = st_crs(neighborhoods))

# Convert extents to sf polygons
alameda_polygon <- st_as_sfc(alameda_extent)
alcatraz_polygon <- st_as_sfc(alcatraz_extent)

# Combine polygons to create exclusion areas
exclude_areas <- st_union(alameda_polygon, alcatraz_polygon)

# Subtract exclusion areas from neighborhoods
neighborhoods <- st_difference(neighborhoods, exclude_areas)%>%
  left_join(., tree_cover_percent, by = "AFFGEOID") %>%
  filter(!is.na(tree_cover_percentage))

# Plot the final map
tmap_mode("plot")
tm_shape(neighborhoods_cleaned) +
  tm_polygons("tree_cover_percentage", 
              palette = "Greens", 
              title = "Urban Tree Canopy Coverage, %",
              style = "cont", 
              lwd = 0) +  # Remove borders around polygons
  tm_layout(frame = FALSE, bg.color = "darkgray")
```
```{r calculate_total_percent}

```
```{r spatial_autocorrelation}

```
```{r correlation_with_race}

```

